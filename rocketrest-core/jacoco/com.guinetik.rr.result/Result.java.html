<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Result.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script>
<!-- <!-- terminal-javadocs-injected [coverage] -->
<link rel="stylesheet" href="../../../terminal-styles/terminaljavadocs-coverage.min.css">
<script src="../../../terminal-styles/terminaljavadocs.min.js" defer></script>
</head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RocketRest Core</a> &gt; <a href="index.source.html" class="el_package">com.guinetik.rr.result</a> &gt; <span class="el_source">Result.java</span></div><h1>Result.java</h1><pre class="source lang-java linenums">package com.guinetik.rr.result;

import java.util.NoSuchElementException;
import java.util.Optional;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;

/**
 * A container object representing either a successful result or an error.
 *
 * &lt;p&gt;Inspired by Rust's {@code Result&lt;T, E&gt;} and Scala's {@code Either[L, R]}, this class
 * provides a functional approach to error handling without exceptions. It forces explicit
 * handling of both success and failure cases, leading to more robust code.
 *
 * &lt;h2&gt;Creating Results&lt;/h2&gt;
 * &lt;pre class=&quot;language-java&quot;&gt;&lt;code&gt;
 * // Success case
 * Result&amp;lt;User, ApiError&amp;gt; success = Result.success(new User(&quot;John&quot;));
 *
 * // Failure case
 * Result&amp;lt;User, ApiError&amp;gt; failure = Result.failure(new ApiError(404, &quot;Not found&quot;));
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * &lt;h2&gt;Checking and Extracting Values&lt;/h2&gt;
 * &lt;pre class=&quot;language-java&quot;&gt;&lt;code&gt;
 * Result&amp;lt;User, ApiError&amp;gt; result = client.fluent().get(&quot;/users/1&quot;, User.class);
 *
 * if (result.isSuccess()) {
 *     User user = result.getValue();
 *     System.out.println(&quot;Found: &quot; + user.getName());
 * } else {
 *     ApiError error = result.getError();
 *     System.err.println(&quot;Error: &quot; + error.getMessage());
 * }
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * &lt;h2&gt;Pattern Matching with match()&lt;/h2&gt;
 * &lt;pre class=&quot;language-java&quot;&gt;&lt;code&gt;
 * result.match(
 *     user -&amp;gt; System.out.println(&quot;Success: &quot; + user.getName()),
 *     error -&amp;gt; System.err.println(&quot;Failed: &quot; + error.getMessage())
 * );
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * &lt;h2&gt;Functional Transformations&lt;/h2&gt;
 * &lt;pre class=&quot;language-java&quot;&gt;&lt;code&gt;
 * // Transform the success value
 * Result&amp;lt;String, ApiError&amp;gt; nameResult = result.map(user -&amp;gt; user.getName());
 *
 * // Transform the error
 * Result&amp;lt;User, String&amp;gt; stringError = result.mapError(err -&amp;gt; err.getMessage());
 *
 * // Chain operations
 * String name = result
 *     .map(User::getName)
 *     .map(String::toUpperCase)
 *     .getOrElse(&quot;Unknown&quot;);
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * &lt;h2&gt;Safe Value Extraction&lt;/h2&gt;
 * &lt;pre class=&quot;language-java&quot;&gt;&lt;code&gt;
 * // With default value
 * User user = result.getOrElse(User.anonymous());
 *
 * // With lazy default
 * User user = result.getOrElseGet(() -&amp;gt; loadDefaultUser());
 *
 * // Throw on failure
 * User user = result.getOrElseThrow(() -&amp;gt; new UserNotFoundException());
 *
 * // Unwrap (throws RuntimeException on failure)
 * User user = result.unwrap();
 *
 * // Convert to Optional
 * Optional&amp;lt;User&amp;gt; optional = result.toOptional();
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * @param &lt;T&gt; the type of the success value
 * @param &lt;E&gt; the type of the error value
 * @author guinetik &amp;lt;guinetik@gmail.com&amp;gt;
 * @see com.guinetik.rr.RocketRest.FluentApi
 * @see ApiError
 * @since 1.0.0
 */
public class Result&lt;T, E&gt; {

    private final T value;
    private final E error;
    private final boolean isSuccess;

<span class="fc" id="L92">    private Result(T value, E error, boolean isSuccess) {</span>
<span class="fc" id="L93">        this.value = value;</span>
<span class="fc" id="L94">        this.error = error;</span>
<span class="fc" id="L95">        this.isSuccess = isSuccess;</span>
<span class="fc" id="L96">    }</span>

    /**
     * Creates a successful Result containing the given value.
     *
     * @param value the value
     * @param &lt;T&gt; the type of the value
     * @param &lt;E&gt; the type of the error
     * @return a successful Result containing the value
     */
    public static &lt;T, E&gt; Result&lt;T, E&gt; success(T value) {
<span class="fc" id="L107">        return new Result&lt;&gt;(value, null, true);</span>
    }

    /**
     * Creates a failed Result containing the given error.
     *
     * @param error the error
     * @param &lt;T&gt; the type of the value
     * @param &lt;E&gt; the type of the error
     * @return a failed Result containing the error
     */
    public static &lt;T, E&gt; Result&lt;T, E&gt; failure(E error) {
<span class="fc" id="L119">        return new Result&lt;&gt;(null, error, false);</span>
    }

    /**
     * Returns whether this Result is a success.
     *
     * @return true if this Result is a success, false otherwise
     */
    public boolean isSuccess() {
<span class="fc" id="L128">        return isSuccess;</span>
    }

    /**
     * Returns whether this Result is a failure.
     *
     * @return true if this Result is a failure, false otherwise
     */
    public boolean isFailure() {
<span class="fc bfc" id="L137" title="All 2 branches covered.">        return !isSuccess;</span>
    }

    /**
     * Gets the value contained in this Result.
     *
     * @return the value
     * @throws NoSuchElementException if this Result is a failure
     */
    public T getValue() {
<span class="pc bpc" id="L147" title="1 of 2 branches missed.">        if (!isSuccess) {</span>
<span class="nc" id="L148">            throw new NoSuchElementException(&quot;Cannot get value from a failure Result&quot;);</span>
        }
<span class="fc" id="L150">        return value;</span>
    }

    /**
     * Gets the error contained in this Result.
     *
     * @return the error
     * @throws NoSuchElementException if this Result is a success
     */
    public E getError() {
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">        if (isSuccess) {</span>
<span class="nc" id="L161">            throw new NoSuchElementException(&quot;Cannot get error from a success Result&quot;);</span>
        }
<span class="fc" id="L163">        return error;</span>
    }

    /**
     * Gets the value contained in this Result or the given default value if this Result is a failure.
     *
     * @param defaultValue the value to return if this Result is a failure
     * @return the value if this Result is a success, otherwise the default value
     */
    public T getOrElse(T defaultValue) {
<span class="fc bfc" id="L173" title="All 2 branches covered.">        return isSuccess ? value : defaultValue;</span>
    }

    /**
     * Gets the value contained in this Result or the value supplied by the given Supplier if this Result is a failure.
     *
     * @param supplier the Supplier to provide the default value
     * @return the value if this Result is a success, otherwise the value from the supplier
     */
    public T getOrElseGet(Supplier&lt;? extends T&gt; supplier) {
<span class="pc bpc" id="L183" title="1 of 2 branches missed.">        return isSuccess ? value : supplier.get();</span>
    }

    /**
     * Gets the value contained in this Result or throws the given exception if this Result is a failure.
     *
     * @param exceptionSupplier the Supplier to provide the exception to throw
     * @param &lt;X&gt; the type of the exception to throw
     * @return the value if this Result is a success
     * @throws X if this Result is a failure
     */
    public &lt;X extends Throwable&gt; T getOrElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) throws X {
<span class="nc bnc" id="L195" title="All 2 branches missed.">        if (isSuccess) {</span>
<span class="nc" id="L196">            return value;</span>
        }
<span class="nc" id="L198">        throw exceptionSupplier.get();</span>
    }
    
    /**
     * Returns the value if this Result is a success, or unwraps the error by throwing an exception.
     * This is similar to Rust's unwrap() method.
     * 
     * @return the contained value
     * @throws RuntimeException if this is a failure, with the error toString() as the message
     */
    public T unwrap() {
<span class="pc bpc" id="L209" title="1 of 2 branches missed.">        if (isSuccess) {</span>
<span class="nc" id="L210">            return value;</span>
        }
<span class="fc" id="L212">        throw new RuntimeException(&quot;Unwrapped a failure Result: &quot; + error);</span>
    }

    /**
     * Maps the value of this Result if it's a success, using the given mapping function.
     *
     * @param mapper the function to apply to the value
     * @param &lt;U&gt; the type of the result of the mapping function
     * @return a new Result with the mapped value if this Result is a success, otherwise a new Result with the same error
     */
    public &lt;U&gt; Result&lt;U, E&gt; map(Function&lt;? super T, ? extends U&gt; mapper) {
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">        if (isSuccess) {</span>
<span class="fc" id="L224">            return Result.success(mapper.apply(value));</span>
        }
<span class="nc" id="L226">        return Result.failure(error);</span>
    }

    /**
     * Maps the error of this Result if it's a failure, using the given mapping function.
     *
     * @param mapper the function to apply to the error
     * @param &lt;F&gt; the type of the result of the mapping function
     * @return a new Result with the mapped error if this Result is a failure, otherwise a new Result with the same value
     */
    public &lt;F&gt; Result&lt;T, F&gt; mapError(Function&lt;? super E, ? extends F&gt; mapper) {
<span class="nc bnc" id="L237" title="All 2 branches missed.">        if (isSuccess) {</span>
<span class="nc" id="L238">            return Result.success(value);</span>
        }
<span class="nc" id="L240">        return Result.failure(mapper.apply(error));</span>
    }

    /**
     * Executes the given consumer if this Result is a success.
     *
     * @param consumer the consumer to execute
     * @return this Result
     */
    public Result&lt;T, E&gt; ifSuccess(Consumer&lt;? super T&gt; consumer) {
<span class="pc bpc" id="L250" title="1 of 2 branches missed.">        if (isSuccess) {</span>
<span class="fc" id="L251">            consumer.accept(value);</span>
        }
<span class="fc" id="L253">        return this;</span>
    }

    /**
     * Executes the given consumer if this Result is a failure.
     *
     * @param consumer the consumer to execute
     * @return this Result
     */
    public Result&lt;T, E&gt; ifFailure(Consumer&lt;? super E&gt; consumer) {
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">        if (!isSuccess) {</span>
<span class="nc" id="L264">            consumer.accept(error);</span>
        }
<span class="fc" id="L266">        return this;</span>
    }

    /**
     * Converts this Result to an Optional containing the value if this Result is a success,
     * or an empty Optional if this Result is a failure.
     *
     * @return an Optional containing the value if this Result is a success, otherwise an empty Optional
     */
    public Optional&lt;T&gt; toOptional() {
<span class="nc bnc" id="L276" title="All 2 branches missed.">        return isSuccess ? Optional.ofNullable(value) : Optional.empty();</span>
    }

    /**
     * Pattern-matches over this Result, executing one of the consumers depending on success/failure.
     * &lt;pre&gt;
     * result.match(value -&amp;gt; System.out.println(value), err -&amp;gt; log.error(err));
     * &lt;/pre&gt;
     *
     * @param successConsumer runs if this result is a success (receives the value)
     * @param errorConsumer   runs if this result is a failure (receives the error)
     * @return this Result for fluent chaining
     */
    public Result&lt;T, E&gt; match(Consumer&lt;? super T&gt; successConsumer, Consumer&lt;? super E&gt; errorConsumer) {
<span class="fc bfc" id="L290" title="All 2 branches covered.">        if (isSuccess) {</span>
<span class="fc" id="L291">            successConsumer.accept(value);</span>
        } else {
<span class="fc" id="L293">            errorConsumer.accept(error);</span>
        }
<span class="fc" id="L295">        return this;</span>
    }

    @Override
    public String toString() {
<span class="nc bnc" id="L300" title="All 2 branches missed.">        if (isSuccess) {</span>
<span class="nc" id="L301">            return &quot;Success[&quot; + value + &quot;]&quot;;</span>
        }
<span class="nc" id="L303">        return &quot;Failure[&quot; + error + &quot;]&quot;;</span>
    }
} 
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>